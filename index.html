<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operating Systems - Programs and Algorithms</title>
</head>
<body>

<h1>Operating Systems - Programs and Algorithms</h1>

<h2>Table of Contents</h2>
<ul>
    <li><a href="#cpu-scheduling">CPU Scheduling Algorithms</a>
        <ul>
            <li><a href="#fcfs">FCFS (First Come First Serve)</a></li>
            <li><a href="#sjf">SJF (Shortest Job First)</a></li>
            <li><a href="#priority">Priority Scheduling (Non-Preemptive)</a></li>
            <li><a href="#round-robin">Round Robin</a></li>
        </ul>
    </li>
    <li><a href="#process-sync">Process Synchronization</a>
        <ul>
            <li><a href="#bankers">Banker's Algorithm</a></li>
            <li><a href="#dining">Dining Philosophers Problem</a></li>
            <li><a href="#producer-consumer">Producer-Consumer Problem</a></li>
        </ul>
    </li>
    <li><a href="#disk-scheduling">Disk Scheduling Algorithms</a>
        <ul>
            <li><a href="#disk-fcfs">FCFS</a></li>
            <li><a href="#sstf">SSTF (Shortest Seek Time First)</a></li>
            <li><a href="#scan">SCAN</a></li>
            <li><a href="#look">LOOK</a></li>
            <li><a href="#cscan">C-SCAN</a></li>
            <li><a href="#clook">C-LOOK</a></li>
        </ul>
    </li>
    <li><a href="#shell-programs">Shell Scripts and C Programs</a>
        <ul>
            <li><a href="#even-odd">Even or Odd</a></li>
            <li><a href="#leap-year">Leap Year</a></li>
            <li><a href="#factorial">Factorial</a></li>
            <li><a href="#swap">Swap Two Integers</a></li>
            <li><a href="#arithmetic">Basic Arithmetic Operations</a></li>
            <li><a href="#multiplication-table">Multiplication Table</a></li>
            <li><a href="#file-check">File Existence Check</a></li>
            <li><a href="#palindrome">Palindrome Check</a></li>
            <li><a href="#sum-digits">Sum of Digits</a></li>
            <li><a href="#word-count">Count Words in a File</a></li>
            <li><a href="#copy-file">Copy File Content</a></li>
            <li><a href="#move-file">Move File</a></li>
            <li><a href="#fork">Process Creation Using fork()</a></li>
            <li><a href="#multiple-fork">Multiple Child Processes</a></li>
            <li><a href="#shutdown">Schedule Shutdown</a></li>
            <li><a href="#list-dir">Display Directory Contents</a></li>
            <li><a href="#list-dir-details">Display Directory with Details</a></li>
        </ul>
    </li>
</ul>

<hr>

<h2 id="cpu-scheduling">CPU Scheduling Algorithms</h2>

<h3 id="fcfs">1. FCFS (First Come First Serve)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i;
    int bt[20], wt[20], tat[20], ct[20];
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    printf("Enter burst times:\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
    }

    wt[0] = 0;
    ct[0] = bt[0];
    tat[0] = ct[0];

    for (i = 1; i &lt; n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];
        ct[i] = ct[i - 1] + bt[i];
        tat[i] = wt[i] + bt[i];
    }

    printf("\nProcess\tBT\tWT\tTAT\tCT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n", i + 1, bt[i], wt[i], tat[i], ct[i]);
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as fcfs.c
gcc fcfs.c -o fcfs
./fcfs
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read the number of processes from the user</li>
    <li>Read burst time for each process</li>
    <li>Set waiting time of first process as zero</li>
    <li>Calculate completion time of first process as its burst time</li>
    <li>Calculate turnaround time of first process as its completion time</li>
    <li>For each subsequent process, calculate waiting time as sum of previous waiting time and previous burst time</li>
    <li>Calculate completion time as sum of previous completion time and current burst time</li>
    <li>Calculate turnaround time as sum of waiting time and burst time</li>
    <li>Display process details with burst time, waiting time, turnaround time, and completion time</li>
</ol>

<hr>

<h3 id="sjf">2. SJF (Shortest Job First)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i, j;
    int bt[20], p[20], wt[20], tat[20], ct[20];
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    printf("Enter burst times:\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
        p[i] = i + 1;
    }

    // Sort by burst time (ascending)
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (bt[j] &gt; bt[j + 1]) {
                int temp = bt[j];  bt[j] = bt[j + 1];  bt[j + 1] = temp;
                temp = p[j];       p[j] = p[j + 1];   p[j + 1] = temp;
            }
        }
    }

    wt[0] = 0;
    ct[0] = bt[0];
    tat[0] = ct[0];

    for (i = 1; i &lt; n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];
        ct[i] = ct[i - 1] + bt[i];
        tat[i] = wt[i] + bt[i];
    }

    printf("\nProcess\tBT\tWT\tTAT\tCT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n", p[i], bt[i], wt[i], tat[i], ct[i]);
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("Average Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as sjf.c
gcc sjf.c -o sjf
./sjf
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read the number of processes from the user</li>
    <li>Read burst time for each process and assign process IDs</li>
    <li>Sort processes by burst time in ascending order using bubble sort</li>
    <li>Keep track of original process IDs during sorting</li>
    <li>Set waiting time of first process (shortest burst time) as zero</li>
    <li>Calculate completion time of first process as its burst time</li>
    <li>For each subsequent process, calculate waiting time, completion time, and turnaround time</li>
    <li>Display process details in order of execution</li>
    <li>Calculate and display average waiting time and turnaround time</li>
</ol>

<hr>

<h3 id="priority">3. Priority Scheduling (Non-Preemptive)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i, completed = 0, t = 0;
    int bt[20], at[20], pr[20], p[20];
    int wt[20], tat[20], ct[20], done[20];
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    for (i = 0; i &lt; n; i++) {
        printf("Arrival time of P%d: ", i + 1);
        scanf("%d", &amp;at[i]);
        printf("Burst time of P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
        printf("Priority of P%d (lower -&gt; higher): ", i + 1);
        scanf("%d", &amp;pr[i]);
        p[i] = i + 1;
        done[i] = 0;
    }

    while (completed &lt; n) {
        int idx = -1;
        int best_pr = 2147483647;

        for (i = 0; i &lt; n; i++) {
            if (!done[i] &amp;&amp; at[i] &lt;= t) {
                if (pr[i] &lt; best_pr) {
                    best_pr = pr[i];
                    idx = i;
                } else if (pr[i] == best_pr) {
                    if (at[i] &lt; at[idx]) idx = i;
                    else if (at[i] == at[idx] &amp;&amp; p[i] &lt; p[idx]) idx = i;
                }
            }
        }

        if (idx == -1) {
            t++;
            continue;
        }

        /* execute process idx */
        t += bt[idx];
        ct[idx] = t;
        tat[idx] = ct[idx] - at[idx];
        wt[idx] = tat[idx] - bt[idx];
        done[idx] = 1;
        completed++;
    }

    printf("\nProcess\tAT\tBT\tPR\tCT\tTAT\tWT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
               p[i], at[i], bt[i], pr[i], ct[i], tat[i], wt[i]);
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as priority.c
gcc priority.c -o priority
./priority
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of processes, arrival time, burst time, and priority for each process</li>
    <li>Initialize all processes as not done</li>
    <li>While not all processes are completed, find the process with highest priority (lowest priority number) that has arrived</li>
    <li>If multiple processes have same priority, select based on arrival time or process ID</li>
    <li>If no process has arrived, increment time</li>
    <li>Execute the selected process completely</li>
    <li>Calculate completion time, turnaround time, and waiting time</li>
    <li>Mark process as done and increment completed counter</li>
    <li>Display process details and average times</li>
</ol>

<hr>

<h3 id="round-robin">4. Round Robin Scheduling</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i, tq;
    int bt[20], at[20], rem[20], wt[20], tat[20], ct[20], p[20];
    int t = 0, completed = 0;
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    for (i = 0; i &lt; n; i++) {
        printf("Arrival time of P%d: ", i + 1);
        scanf("%d", &amp;at[i]);
        printf("Burst time of P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
        rem[i] = bt[i];
        p[i] = i + 1;
    }

    printf("Enter time quantum: ");
    scanf("%d", &amp;tq);

    while (completed &lt; n) {
        int done = 1;

        for (i = 0; i &lt; n; i++) {
            if (at[i] &lt;= t &amp;&amp; rem[i] &gt; 0) {
                done = 0;

                if (rem[i] &gt; tq) {
                    t += tq;
                    rem[i] -= tq;
                } else {
                    t += rem[i];
                    ct[i] = t;
                    rem[i] = 0;
                    completed++;
                }
            }
        }

        if (done) t++;
    }

    for (i = 0; i &lt; n; i++) {
        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nProcess\tAT\tBT\tCT\tTAT\tWT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\n",
               p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as round_robin.c
gcc round_robin.c -o round_robin
./round_robin
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of processes, arrival time, and burst time for each process</li>
    <li>Read time quantum value</li>
    <li>Initialize remaining time for each process equal to burst time</li>
    <li>While not all processes are completed, iterate through all processes</li>
    <li>For each process that has arrived and has remaining time, execute it for time quantum or remaining time (whichever is smaller)</li>
    <li>If process completes, record completion time and increment completed counter</li>
    <li>If no process is ready, increment time</li>
    <li>Calculate turnaround time and waiting time for each process</li>
    <li>Display process details and average times</li>
</ol>

<hr>

<h2 id="process-sync">Process Synchronization</h2>

<h3 id="bankers">1. Banker's Algorithm</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int P, R;
    printf("Enter number of processes: ");
    scanf("%d", &amp;P);

    printf("Enter number of resources: ");
    scanf("%d", &amp;R);

    int allocation[10][10], max[10][10], need[10][10], available[10];
    int finished[10], safeSeq[10];

    int i, j;

    printf("Enter Allocation matrix:\n");
    for (i = 0; i &lt; P; i++) {
        for (j = 0; j &lt; R; j++) {
            scanf("%d", &amp;allocation[i][j]);
        }
    }

    printf("Enter Max matrix:\n");
    for (i = 0; i &lt; P; i++) {
        for (j = 0; j &lt; R; j++) {
            scanf("%d", &amp;max[i][j]);
        }
    }

    printf("Enter Available resources:\n");
    for (i = 0; i &lt; R; i++) {
        scanf("%d", &amp;available[i]);
    }

    // Calculate Need = Max - Allocation
    for (i = 0; i &lt; P; i++) {
        for (j = 0; j &lt; R; j++) {
            need[i][j] = max[i][j] - allocation[i][j];
        }
        finished[i] = 0;
    }

    int count = 0;

    while (count &lt; P) {
        int found = 0;

        for (i = 0; i &lt; P; i++) {
            if (finished[i] == 0) {
                int canAllocate = 1;

                for (j = 0; j &lt; R; j++) {
                    if (need[i][j] &gt; available[j]) {
                        canAllocate = 0;
                        break;
                    }
                }

                if (canAllocate) {
                    for (j = 0; j &lt; R; j++)
                        available[j] += allocation[i][j];

                    safeSeq[count++] = i;
                    finished[i] = 1;
                    found = 1;
                }
            }
        }

        if (found == 0) {
            printf("System is not in a safe state.\n");
            return 0;
        }
    }

    printf("System is in a safe state.\nSafe sequence: ");
    for (i = 0; i &lt; P; i++)
        printf("P%d ", safeSeq[i]);
    printf("\n");

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as bankers.c
gcc bankers.c -o bankers
./bankers
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of processes and resources</li>
    <li>Read allocation matrix (current allocation for each process)</li>
    <li>Read max matrix (maximum demand for each process)</li>
    <li>Read available resources vector</li>
    <li>Calculate need matrix as Max minus Allocation</li>
    <li>Mark all processes as unfinished</li>
    <li>While not all processes are finished, find a process whose need can be satisfied with available resources</li>
    <li>If found, add its allocated resources to available, mark it as finished, and add to safe sequence</li>
    <li>If no such process is found, system is in unsafe state</li>
    <li>If all processes finish, system is in safe state</li>
    <li>Display the safe sequence</li>
</ol>

<hr>

<h3 id="dining">2. Dining Philosophers Problem</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;unistd.h&gt;

#define N 5  /* number of philosophers */

sem_t chopstick[N];

void *philosopher(void *arg) {
    int id = *(int *)arg;
    for (;;) {
        printf("Philosopher %d is thinking...\n", id);
        sleep(1);

        /* pick up left chopstick */
        sem_wait(&amp;chopstick[id]);

        /* pick up right chopstick */
        sem_wait(&amp;chopstick[(id + 1) % N]);

        printf("Philosopher %d is eating...\n", id);
        sleep(2);

        /* put down left chopstick */
        sem_post(&amp;chopstick[id]);

        /* put down right chopstick */
        sem_post(&amp;chopstick[(id + 1) % N]);

        printf("Philosopher %d finished eating and put down chopsticks.\n", id);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[N];
    int ids[N];

    for (int i = 0; i &lt; N; i++) {
        if (sem_init(&amp;chopstick[i], 0, 1) != 0) {
            perror("sem_init");
            return EXIT_FAILURE;
        }
    }

    for (int i = 0; i &lt; N; i++) {
        ids[i] = i;
        if (pthread_create(&amp;threads[i], NULL, philosopher, &amp;ids[i]) != 0) {
            perror("pthread_create");
            return EXIT_FAILURE;
        }
    }

    for (int i = 0; i &lt; N; i++) {
        pthread_join(threads[i], NULL);
    }

    for (int i = 0; i &lt; N; i++) sem_destroy(&amp;chopstick[i]);

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as dining_philosophers.c
gcc dining_philosophers.c -o dining_philosophers -pthread
./dining_philosophers
# Press Ctrl+C to stop the program as it runs indefinitely
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Initialize a semaphore for each chopstick with value one</li>
    <li>Create a philosopher thread for each philosopher</li>
    <li>Each philosopher thread runs an infinite loop with thinking and eating phases</li>
    <li>In thinking phase, display that philosopher is thinking and wait for some time</li>
    <li>To eat, philosopher picks up left chopstick by waiting on its semaphore</li>
    <li>Then picks up right chopstick by waiting on the next semaphore</li>
    <li>Display that philosopher is eating and wait for some time</li>
    <li>After eating, put down left chopstick by signaling its semaphore</li>
    <li>Put down right chopstick by signaling the next semaphore</li>
    <li>Display that philosopher finished eating</li>
    <li>Return to thinking phase</li>
    <li>Main thread waits for all philosopher threads to complete</li>
</ol>

<hr>

<h3 id="producer-consumer">3. Producer-Consumer Problem</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0, out = 0, count = 0;

pthread_mutex_t mutex;
pthread_cond_t not_full;
pthread_cond_t not_empty;

void* producer(void* arg) {
    (void)arg;
    while (1) {
        int item = rand() % 100; // produce an item

        pthread_mutex_lock(&amp;mutex);

        while (count == BUFFER_SIZE) // buffer full
            pthread_cond_wait(&amp;not_full, &amp;mutex);

        buffer[in] = item;
        printf("Produced: %d at index %d\n", item, in);
        in = (in + 1) % BUFFER_SIZE;
        count++;

        pthread_cond_signal(&amp;not_empty); // signal buffer has item
        pthread_mutex_unlock(&amp;mutex);

        sleep(1); // simulate production time
    }
    return NULL;
}

void* consumer(void* arg) {
    (void)arg;
    while (1) {
        pthread_mutex_lock(&amp;mutex);

        while (count == 0) // buffer empty
            pthread_cond_wait(&amp;not_empty, &amp;mutex);

        int item = buffer[out];
        printf("Consumed: %d from index %d\n", item, out);
        out = (out + 1) % BUFFER_SIZE;
        count--;

        pthread_cond_signal(&amp;not_full); // signal buffer has space
        pthread_mutex_unlock(&amp;mutex);

        sleep(1); // simulate consumption time
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;

    srand((unsigned)time(NULL));

    pthread_mutex_init(&amp;mutex, NULL);
    pthread_cond_init(&amp;not_full, NULL);
    pthread_cond_init(&amp;not_empty, NULL);

    if (pthread_create(&amp;prod, NULL, producer, NULL) != 0) {
        perror("Failed to create producer thread");
        return 1;
    }
    if (pthread_create(&amp;cons, NULL, consumer, NULL) != 0) {
        perror("Failed to create consumer thread");
        return 1;
    }

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&amp;mutex);
    pthread_cond_destroy(&amp;not_full);
    pthread_cond_destroy(&amp;not_empty);

    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as producer_consumer.c
gcc producer_consumer.c -o producer_consumer -pthread
./producer_consumer
# Press Ctrl+C to stop the program as it runs indefinitely
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Initialize a buffer of fixed size with head and tail pointers and count variable</li>
    <li>Initialize a mutex lock for synchronization</li>
    <li>Initialize condition variables for buffer not full and buffer not empty</li>
    <li>Create producer thread that runs indefinitely</li>
    <li>Producer generates a random item</li>
    <li>Lock the mutex</li>
    <li>If buffer is full, wait on not full condition variable</li>
    <li>Add item to buffer at head position</li>
    <li>Increment head pointer circularly and increment count</li>
    <li>Signal not empty condition variable</li>
    <li>Unlock the mutex</li>
    <li>Create consumer thread that runs indefinitely</li>
    <li>Consumer locks the mutex</li>
    <li>If buffer is empty, wait on not empty condition variable</li>
    <li>Remove item from buffer at tail position</li>
    <li>Increment tail pointer circularly and decrement count</li>
    <li>Signal not full condition variable</li>
    <li>Unlock the mutex</li>
</ol>

<hr>

<h2 id="disk-scheduling">Disk Scheduling Algorithms</h2>

<h3 id="disk-fcfs">1. FCFS (First Come First Serve)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n, head, i, total = 0;
    int req[100];

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("\nFCFS Order: %d ", head);

    for (i = 0; i &lt; n; i++) {
        total += abs(req[i] - head);
        head = req[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as disk_fcfs.c
gcc disk_fcfs.c -o disk_fcfs
./disk_fcfs
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions in order</li>
    <li>Read initial head position</li>
    <li>Start from initial head position</li>
    <li>Service each request in the order they arrived</li>
    <li>For each request, calculate absolute difference from current head position</li>
    <li>Add this difference to total head movement</li>
    <li>Move head to the request position</li>
    <li>Continue until all requests are serviced</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="sstf">2. SSTF (Shortest Seek Time First)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n, head, i, count = 0;
    int req[100], visited[100] = {0};
    int total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("\nSSTF Order: %d ", head);

    while (count &lt; n) {
        int min = 9999, index = -1;

        for (i = 0; i &lt; n; i++) {
            if (!visited[i]) {
                int diff = abs(req[i] - head);
                if (diff &lt; min) {
                    min = diff;
                    index = i;
                }
            }
        }

        visited[index] = 1;
        total += abs(req[index] - head);
        head = req[index];

        printf("-&gt; %d ", head);
        count++;
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as disk_sstf.c
gcc disk_sstf.c -o disk_sstf
./disk_sstf
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position</li>
    <li>Mark all requests as unvisited</li>
    <li>Start from initial head position</li>
    <li>While there are unvisited requests, find the unvisited request closest to current head position</li>
    <li>Calculate distance for all unvisited requests and select the one with minimum distance</li>
    <li>Mark that request as visited</li>
    <li>Add the distance to total head movement</li>
    <li>Move head to that request position</li>
    <li>Continue until all requests are visited</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="scan">3. SCAN</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, disk, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("Enter disk size: ");
    scanf("%d", &amp;disk);

    right[r++] = disk;
    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nSCAN Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    for (i = l - 1; i &gt;= 0; i--) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as disk_scan.c
gcc disk_scan.c -o disk_scan
./disk_scan
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position and disk size</li>
    <li>Add disk end position to right array</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order including disk end, calculating total head movement</li>
    <li>After reaching disk end, reverse direction</li>
    <li>Service all requests in left array in descending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="look">4. LOOK</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nLOOK Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    for (i = l - 1; i &gt;= 0; i--) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as disk_look.c
gcc disk_look.c -o disk_look
./disk_look
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order, calculating total head movement</li>
    <li>After reaching the last request in right direction, reverse direction</li>
    <li>Service all requests in left array in descending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="cscan">5. C-SCAN (Circular SCAN)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, disk, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("Enter disk size: ");
    scanf("%d", &amp;disk);

    right[r++] = disk;
    left[l++] = 0;

    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nCSCAN Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    head = 0;

    for (i = 0; i &lt; l; i++) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as disk_cscan.c
gcc disk_cscan.c -o disk_cscan
./disk_cscan
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position and disk size</li>
    <li>Add disk end position to right array and zero to left array</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both left and right arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order including disk end, calculating total head movement</li>
    <li>Jump to beginning of disk at position zero</li>
    <li>Service all requests in left array in ascending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="clook">6. C-LOOK (Circular LOOK)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nCLOOK Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    total += abs(head - left[0]);
    head = left[0];

    for (i = 0; i &lt; l; i++) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as disk_clook.c
gcc disk_clook.c -o disk_clook
./disk_clook
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both left and right arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order, calculating total head movement</li>
    <li>Jump to the smallest request in left array</li>
    <li>Service all requests in left array in ascending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h2 id="shell-programs">Shell Scripts and C Programs</h2>

<h3 id="even-odd">1. Even or Odd</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
if [ $((num % 2)) -eq 0 ]; then
    echo "$num is Even"
else
    echo "$num is Odd"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num;
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    if (num % 2 == 0)
        printf("%d is Even\n", num);
    else
        printf("%d is Odd\n", num);
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as even_odd.c
gcc even_odd.c -o even_odd
./even_odd
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Divide the number by 2 and find the remainder</li>
    <li>If remainder is zero, the number is even</li>
    <li>Otherwise, the number is odd</li>
    <li>Display the result</li>
</ol>

<hr>

<h3 id="leap-year">2. Leap Year</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a year:"
read year
if [ $((year % 400)) -eq 0 ]; then
    echo "$year is a Leap Year"
elif [ $((year % 100)) -eq 0 ]; then
    echo "$year is not a Leap Year"
elif [ $((year % 4)) -eq 0 ]; then
    echo "$year is a Leap Year"
else
    echo "$year is not a Leap Year"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int year;
    printf("Enter a year: ");
    scanf("%d", &amp;year);
    
    if (year % 400 == 0)
        printf("%d is a Leap Year\n", year);
    else if (year % 100 == 0)
        printf("%d is not a Leap Year\n", year);
    else if (year % 4 == 0)
        printf("%d is a Leap Year\n", year);
    else
        printf("%d is not a Leap Year\n", year);
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as leap_year.c
gcc leap_year.c -o leap_year
./leap_year
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a year from the user</li>
    <li>Check if year is divisible by 400, if yes then it is a leap year</li>
    <li>Else check if year is divisible by 100, if yes then it is not a leap year</li>
    <li>Else check if year is divisible by 4, if yes then it is a leap year</li>
    <li>Otherwise it is not a leap year</li>
    <li>Display the result</li>
</ol>

<hr>

<h3 id="factorial">3. Factorial</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
fact=1
i=1
while [ $i -le $num ]; do
    fact=$((fact * i))
    i=$((i + 1))
done
echo "Factorial of $num is $fact"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num, i;
    long long fact = 1;
    
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    for (i = 1; i &lt;= num; i++) {
        fact *= i;
    }
    
    printf("Factorial of %d is %lld\n", num, fact);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as factorial.c
gcc factorial.c -o factorial
./factorial
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Initialize factorial variable to 1</li>
    <li>Initialize counter variable to 1</li>
    <li>Run a loop from 1 to the number</li>
    <li>In each iteration, multiply factorial by counter value</li>
    <li>Increment counter</li>
    <li>After loop ends, display the factorial value</li>
</ol>

<hr>

<h3 id="swap">4. Swap Two Integers</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter first number:"
read a
echo "Enter second number:"
read b
echo "Before swap: a=$a, b=$b"
temp=$a
a=$b
b=$temp
echo "After swap: a=$a, b=$b"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int a, b, temp;
    
    printf("Enter first number: ");
    scanf("%d", &amp;a);
    printf("Enter second number: ");
    scanf("%d", &amp;b);
    
    printf("Before swap: a=%d, b=%d\n", a, b);
    
    temp = a;
    a = b;
    b = temp;
    
    printf("After swap: a=%d, b=%d\n", a, b);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as swap.c
gcc swap.c -o swap
./swap
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read two numbers from the user into variables a and b</li>
    <li>Display values before swapping</li>
    <li>Store value of a in a temporary variable</li>
    <li>Assign value of b to a</li>
    <li>Assign value of temporary variable to b</li>
    <li>Display values after swapping</li>
</ol>

<hr>

<h3 id="arithmetic">5. Basic Arithmetic Operations</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter first number:"
read a
echo "Enter second number:"
read b
echo "Addition: $((a + b))"
echo "Subtraction: $((a - b))"
echo "Multiplication: $((a * b))"
if [ $b -ne 0 ]; then
    echo "Division: $((a / b))"
else
    echo "Division: Cannot divide by zero"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    float a, b;
    
    printf("Enter first number: ");
    scanf("%f", &amp;a);
    printf("Enter second number: ");
    scanf("%f", &amp;b);
    
    printf("Addition: %.2f\n", a + b);
    printf("Subtraction: %.2f\n", a - b);
    printf("Multiplication: %.2f\n", a * b);
    
    if (b != 0)
        printf("Division: %.2f\n", a / b);
    else
        printf("Division: Cannot divide by zero\n");
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as arithmetic.c
gcc arithmetic.c -o arithmetic
./arithmetic
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read two numbers from the user</li>
    <li>Perform addition by adding the two numbers and display result</li>
    <li>Perform subtraction by subtracting second from first and display result</li>
    <li>Perform multiplication by multiplying the two numbers and display result</li>
    <li>Check if second number is not zero</li>
    <li>If not zero, perform division by dividing first by second and display result</li>
    <li>If zero, display error message for division by zero</li>
</ol>

<hr>

<h3 id="multiplication-table">6. Multiplication Table</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
echo "Multiplication table of $num:"
for i in {1..10}; do
    echo "$num x $i = $((num * i))"
done
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num, i;
    
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    printf("Multiplication table of %d:\n", num);
    for (i = 1; i &lt;= 10; i++) {
        printf("%d x %d = %d\n", num, i, num * i);
    }
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as multiplication_table.c
gcc multiplication_table.c -o multiplication_table
./multiplication_table
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Initialize counter variable to 1</li>
    <li>Run a loop from 1 to 10</li>
    <li>In each iteration, multiply the number by counter value</li>
    <li>Display the multiplication expression and result</li>
    <li>Increment counter</li>
    <li>Continue until counter reaches 10</li>
</ol>

<hr>

<h3 id="file-check">7. File Existence Check</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter filename:"
read filename
if [ -e "$filename" ]; then
    echo "File '$filename' exists"
    if [ -f "$filename" ]; then
        echo "It is a regular file"
    elif [ -d "$filename" ]; then
        echo "It is a directory"
    fi
else
    echo "File '$filename' does not exist"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    char filename[100];
    FILE *file;
    
    printf("Enter filename: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    
    if (file != NULL) {
        printf("File '%s' exists\n", filename);
        fclose(file);
    } else {
        printf("File '%s' does not exist\n", filename);
    }
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as file_check.c
gcc file_check.c -o file_check
./file_check
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read filename from the user</li>
    <li>Attempt to open the file in read mode</li>
    <li>If file pointer is not null, file exists</li>
    <li>Display message that file exists</li>
    <li>Close the file</li>
    <li>If file pointer is null, file does not exist</li>
    <li>Display message that file does not exist</li>
</ol>

<hr>

<h3 id="palindrome">8. Palindrome Check</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number or string:"
read input
reversed=$(echo "$input" | rev)
if [ "$input" = "$reversed" ]; then
    echo "'$input' is a Palindrome"
else
    echo "'$input' is not a Palindrome"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[100], rev[100];
    int i, j, len;
    
    printf("Enter a string: ");
    scanf("%s", str);
    
    len = strlen(str);
    
    for (i = len - 1, j = 0; i &gt;= 0; i--, j++) {
        rev[j] = str[i];
    }
    rev[j] = '\0';
    
    if (strcmp(str, rev) == 0)
        printf("'%s' is a Palindrome\n", str);
    else
        printf("'%s' is not a Palindrome\n", str);
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as palindrome.c
gcc palindrome.c -o palindrome
./palindrome
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a string or number from the user</li>
    <li>Find the length of the input</li>
    <li>Create a new string to store reversed version</li>
    <li>Start from last character of original string</li>
    <li>Copy each character to the beginning of reversed string</li>
    <li>Continue until all characters are copied</li>
    <li>Compare original string with reversed string</li>
    <li>If both are equal, input is a palindrome</li>
    <li>Otherwise, input is not a palindrome</li>
    <li>Display the result</li>
</ol>

<hr>

<h3 id="sum-digits">9. Sum of Digits</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
sum=0
temp=$num
while [ $temp -gt 0 ]; do
    digit=$((temp % 10))
    sum=$((sum + digit))
    temp=$((temp / 10))
done
echo "Sum of digits of $num is $sum"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num, sum = 0, digit, temp;
    
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    temp = num;
    
    while (temp &gt; 0) {
        digit = temp % 10;
        sum += digit;
        temp /= 10;
    }
    
    printf("Sum of digits of %d is %d\n", num, sum);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as sum_digits.c
gcc sum_digits.c -o sum_digits
./sum_digits
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Initialize sum variable to zero</li>
    <li>Store the number in a temporary variable</li>
    <li>While temporary variable is greater than zero, extract last digit using modulo 10 operation</li>
    <li>Add the digit to sum</li>
    <li>Remove last digit by dividing temporary variable by 10</li>
    <li>Continue loop until all digits are processed</li>
    <li>Display the sum of digits</li>
</ol>

<hr>

<h3 id="word-count">10. Count Words in a File</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter filename:"
read filename
if [ -f "$filename" ]; then
    words=$(wc -w &lt; "$filename")
    echo "Number of words in '$filename': $words"
else
    echo "File '$filename' does not exist"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
    char filename[100];
    FILE *file;
    char ch;
    int words = 0, inWord = 0;
    
    printf("Enter filename: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    
    if (file == NULL) {
        printf("File '%s' does not exist\n", filename);
        return 1;
    }
    
    while ((ch = fgetc(file)) != EOF) {
        if (isspace(ch)) {
            inWord = 0;
        } else if (inWord == 0) {
            inWord = 1;
            words++;
        }
    }
    
    fclose(file);
    printf("Number of words in '%s': %d\n", filename, words);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as word_count.c
gcc word_count.c -o word_count
./word_count
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read filename from the user</li>
    <li>Attempt to open the file in read mode</li>
    <li>If file does not exist, display error message and exit</li>
    <li>Initialize word counter to zero</li>
    <li>Initialize flag variable to track if currently inside a word</li>
    <li>Read characters from file one by one until end of file</li>
    <li>If character is a space, tab, or newline, set flag to not in word</li>
    <li>If character is not a space and flag indicates not in word, increment word counter and set flag to in word</li>
    <li>Continue until end of file is reached</li>
    <li>Close the file</li>
    <li>Display the total word count</li>
</ol>

<hr>

<h3 id="copy-file">11. Copy File Content Without cp Command</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter source filename:"
read source
echo "Enter destination filename:"
read dest

if [ ! -f "$source" ]; then
    echo "Source file does not exist"
    exit 1
fi

while IFS= read -r line; do
    echo "$line" &gt;&gt; "$dest"
done &lt; "$source"

echo "File copied successfully from '$source' to '$dest'"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    char source[100], dest[100];
    FILE *src, *dst;
    char ch;
    
    printf("Enter source filename: ");
    scanf("%s", source);
    printf("Enter destination filename: ");
    scanf("%s", dest);
    
    src = fopen(source, "r");
    if (src == NULL) {
        printf("Cannot open source file '%s'\n", source);
        return 1;
    }
    
    dst = fopen(dest, "w");
    if (dst == NULL) {
        printf("Cannot create destination file '%s'\n", dest);
        fclose(src);
        return 1;
    }
    
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }
    
    printf("File copied successfully from '%s' to '%s'\n", source, dest);
    
    fclose(src);
    fclose(dst);
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as copy_file.c
gcc copy_file.c -o copy_file
./copy_file
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read source filename from the user</li>
    <li>Read destination filename from the user</li>
    <li>Open source file in read mode</li>
    <li>If source file cannot be opened, display error message and exit</li>
    <li>Open destination file in write mode</li>
    <li>If destination file cannot be created, close source file and exit</li>
    <li>Read characters from source file one by one until end of file</li>
    <li>Write each character to destination file</li>
    <li>Continue until all characters are copied</li>
    <li>Close both source and destination files</li>
    <li>Display success message</li>
</ol>

<hr>

<h3 id="move-file">12. Move File from One Directory to Another Without mv Command</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter source file path:"
read source
echo "Enter destination directory path:"
read destdir

if [ ! -f "$source" ]; then
    echo "Source file does not exist"
    exit 1
fi

if [ ! -d "$destdir" ]; then
    echo "Destination directory does not exist"
    exit 1
fi

filename=$(basename "$source")
destination="$destdir/$filename"

while IFS= read -r line; do
    echo "$line" &gt;&gt; "$destination"
done &lt; "$source"

rm "$source"

echo "File moved successfully from '$source' to '$destination'"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    char source[200], destdir[200], dest[300];
    FILE *src, *dst;
    char ch;
    char *filename;
    
    printf("Enter source file path: ");
    scanf("%s", source);
    printf("Enter destination directory path: ");
    scanf("%s", destdir);
    
    src = fopen(source, "r");
    if (src == NULL) {
        printf("Cannot open source file '%s'\n", source);
        return 1;
    }
    
    // Extract filename from source path
    filename = strrchr(source, '/');
    if (filename == NULL)
        filename = source;
    else
        filename++;
    
    // Create destination path
    sprintf(dest, "%s/%s", destdir, filename);
    
    dst = fopen(dest, "w");
    if (dst == NULL) {
        printf("Cannot create file in destination directory\n");
        fclose(src);
        return 1;
    }
    
    // Copy content
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }
    
    fclose(src);
    fclose(dst);
    
    // Delete source file
    if (remove(source) == 0)
        printf("File moved successfully from '%s' to '%s'\n", source, dest);
    else
        printf("Error deleting source file\n");
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as move_file.c
gcc move_file.c -o move_file
./move_file
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read source file path from the user</li>
    <li>Read destination directory path from the user</li>
    <li>Check if source file exists, if not display error and exit</li>
    <li>Check if destination directory exists, if not display error and exit</li>
    <li>Extract filename from the source path</li>
    <li>Construct destination file path by combining destination directory and filename</li>
    <li>Open source file in read mode</li>
    <li>If source file cannot be opened, display error and exit</li>
    <li>Open destination file in write mode</li>
    <li>If destination file cannot be created, close source and exit</li>
    <li>Read characters from source file one by one until end of file</li>
    <li>Write each character to destination file</li>
    <li>Close both files</li>
    <li>Delete the source file using remove function</li>
    <li>Display success or error message</li>
</ol>

<hr>

<h3 id="fork">13. Process Creation Using fork()</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Parent Process: PID = $"
echo "Creating child process..."

# Shell doesn't have fork, but we can use background process
(
    echo "Child Process: PID = $, Parent PID = $PPID"
    echo "Child process executing..."
    sleep 2
    echo "Child process completed"
) &amp;

child_pid=$!
echo "Parent Process: Created child with PID = $child_pid"
wait $child_pid
echo "Parent Process: Child has terminated"
echo "Parent process completed"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    pid_t pid;
    
    printf("Parent Process: PID = %d\n", getpid());
    printf("Creating child process...\n");
    
    pid = fork();
    
    if (pid &lt; 0) {
        printf("Fork failed!\n");
        return 1;
    }
    else if (pid == 0) {
        // Child process
        printf("\nChild Process: PID = %d, Parent PID = %d\n", 
               getpid(), getppid());
        printf("Child process executing...\n");
        sleep(2);
        printf("Child process completed\n");
    }
    else {
        // Parent process
        printf("Parent Process: Created child with PID = %d\n", pid);
        wait(NULL);
        printf("Parent Process: Child has terminated\n");
        printf("Parent process completed\n");
    }
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as fork_demo.c
gcc fork_demo.c -o fork_demo
./fork_demo
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Display parent process ID</li>
    <li>Call fork system call to create a new process</li>
    <li>Fork returns process ID of child to parent and zero to child</li>
    <li>If fork returns negative value, process creation failed, display error and exit</li>
    <li>If fork returns zero, currently executing in child process</li>
    <li>In child process, display child process ID and parent process ID</li>
    <li>Execute child process tasks</li>
    <li>Display child completion message</li>
    <li>If fork returns positive value, currently executing in parent process</li>
    <li>In parent process, display the child process ID that was created</li>
    <li>Wait for child process to complete using wait system call</li>
    <li>After child terminates, display termination message</li>
    <li>Continue with parent process tasks</li>
    <li>Display parent completion message</li>
</ol>

<hr>

<h3 id="multiple-fork">14. Multiple Child Processes Using fork()</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    pid_t pid;
    int i, n;
    
    printf("Enter number of child processes to create: ");
    scanf("%d", &amp;n);
    
    printf("\nParent Process: PID = %d\n", getpid());
    
    for (i = 0; i &lt; n; i++) {
        pid = fork();
        
        if (pid &lt; 0) {
            printf("Fork failed!\n");
            return 1;
        }
        else if (pid == 0) {
            // Child process
            printf("Child %d: PID = %d, Parent PID = %d\n", 
                   i + 1, getpid(), getppid());
            sleep(1);
            printf("Child %d completed\n", i + 1);
            return 0; // Child exits
        }
        else {
            // Parent process
            printf("Parent created Child %d with PID = %d\n", i + 1, pid);
        }
    }
    
    // Parent waits for all children
    for (i = 0; i &lt; n; i++) {
        wait(NULL);
        printf("Parent: Child process %d terminated\n", i + 1);
    }
    
    printf("\nParent process completed\n");
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as multiple_fork.c
gcc multiple_fork.c -o multiple_fork
./multiple_fork
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of child processes to create from user</li>
    <li>Display parent process ID</li>
    <li>Initialize loop counter to zero</li>
    <li>Run loop for specified number of times</li>
    <li>In each iteration, call fork to create child process</li>
    <li>If fork fails, display error and exit</li>
    <li>If fork returns zero, executing in child process</li>
    <li>In child process, display child number, process ID, and parent ID</li>
    <li>Execute child tasks and exit child process</li>
    <li>If fork returns positive value, executing in parent process</li>
    <li>In parent, display child process ID that was created</li>
    <li>Continue loop to create remaining children</li>
    <li>After all children are created, parent waits for each child</li>
    <li>Run another loop to wait for all children using wait system call</li>
    <li>Display message when each child terminates</li>
    <li>After all children complete, display parent completion message</li>
</ol>

<hr>

<h3 id="shutdown">15. Schedule Shutdown in X Minutes</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter minutes until shutdown:"
read minutes

if [ $minutes -le 0 ]; then
    echo "Invalid time. Please enter a positive number."
    exit 1
fi

echo "System will shutdown in $minutes minute(s)"
echo "To cancel, use: shutdown -c"

# Schedule shutdown
shutdown -h +$minutes "System is shutting down in $minutes minutes"

# Alternative: using sleep and shutdown now
# sleep $((minutes * 60))
# shutdown -h now
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int minutes;
    char command[200];
    
    printf("Enter minutes until shutdown: ");
    scanf("%d", &amp;minutes);
    
    if (minutes &lt;= 0) {
        printf("Invalid time. Please enter a positive number.\n");
        return 1;
    }
    
    printf("System will shutdown in %d minute(s)\n", minutes);
    printf("To cancel, use: shutdown -c\n");
    
    // Method 1: Using shutdown command with time
    sprintf(command, "shutdown -h +%d \"System shutting down in %d minutes\"", 
            minutes, minutes);
    system(command);
    
    // Method 2: Sleep then shutdown (alternative)
    /*
    printf("Waiting for %d minute(s)...\n", minutes);
    sleep(minutes * 60);
    system("shutdown -h now");
    */
    
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as schedule_shutdown.c
gcc schedule_shutdown.c -o schedule_shutdown
sudo ./schedule_shutdown
# Note: Requires sudo/root privileges to run shutdown command
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of minutes from the user</li>
    <li>Validate that minutes is a positive number</li>
    <li>If invalid, display error message and exit</li>
    <li>Display message showing scheduled shutdown time</li>
    <li>Display information about canceling the shutdown</li>
    <li>Construct shutdown command with specified minutes</li>
    <li>Execute the shutdown command using system call</li>
    <li>Alternative approach: use sleep function to wait for specified minutes converted to seconds</li>
    <li>After sleep completes, execute immediate shutdown command</li>
    <li>Display confirmation message</li>
</ol>

<hr>

<h3 id="list-dir">16. Display Contents of a Directory</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter directory path (or . for current):"
read dirpath

if [ ! -d "$dirpath" ]; then
    echo "Directory '$dirpath' does not exist"
    exit 1
fi

echo "Contents of directory '$dirpath':"
echo "================================"

for item in "$dirpath"/*; do
    if [ -f "$item" ]; then
        echo "[FILE] $(basename "$item")"
    elif [ -d "$item" ]; then
        echo "[DIR]  $(basename "$item")"
    fi
done

# Alternative: Simple ls
# ls -l "$dirpath"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;

int main() {
    char dirpath[200], fullpath[300];
    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    
    printf("Enter directory path (or . for current): ");
    scanf("%s", dirpath);
    
    dir = opendir(dirpath);
    
    if (dir == NULL) {
        printf("Cannot open directory '%s'\n", dirpath);
        return 1;
    }
    
    printf("\nContents of directory '%s':\n", dirpath);
    printf("================================\n");
    
    while ((entry = readdir(dir)) != NULL) {
        // Skip . and ..
        if (strcmp(entry-&gt;d_name, ".") == 0 || 
            strcmp(entry-&gt;d_name, "..") == 0)
            continue;
        
        // Create full path for stat
        sprintf(fullpath, "%s/%s", dirpath, entry-&gt;d_name);
        
        if (stat(fullpath, &amp;fileStat) == 0) {
            if (S_ISDIR(fileStat.st_mode))
                printf("[DIR]  %s\n", entry-&gt;d_name);
            else if (S_ISREG(fileStat.st_mode))
                printf("[FILE] %s\n", entry-&gt;d_name);
            else
                printf("[OTHER] %s\n", entry-&gt;d_name);
        }
    }
    
    closedir(dir);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as list_dir.c
gcc list_dir.c -o list_dir
./list_dir
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read directory path from the user</li>
    <li>If user enters dot, use current directory</li>
    <li>Attempt to open the directory using opendir function</li>
    <li>If directory cannot be opened, display error message and exit</li>
    <li>Display header showing directory path</li>
    <li>Read directory entries one by one using readdir function</li>
    <li>For each entry, skip the special entries dot and dot-dot</li>
    <li>Construct full path by combining directory path and entry name</li>
    <li>Use stat function to get information about the entry</li>
    <li>Check if entry is a directory using file mode flags</li>
    <li>If directory, display with DIR label</li>
    <li>Check if entry is a regular file using file mode flags</li>
    <li>If regular file, display with FILE label</li>
    <li>For other types, display with OTHER label</li>
    <li>Continue until all entries are read</li>
    <li>Close the directory using closedir function</li>
</ol>

<hr>

<h3 id="list-dir-details">17. Display Directory Contents with Details</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;pwd.h&gt;
#include &lt;grp.h&gt;

int main() {
    char dirpath[200], fullpath[300];
    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    
    printf("Enter directory path (or . for current): ");
    scanf("%s", dirpath);
    
    dir = opendir(dirpath);
    
    if (dir == NULL) {
        printf("Cannot open directory '%s'\n", dirpath);
        return 1;
    }
    
    printf("\nDetailed contents of directory '%s':\n", dirpath);
    printf("Type\tSize(B)\t\tName\n");
    printf("================================================\n");
    
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry-&gt;d_name, ".") == 0 || 
            strcmp(entry-&gt;d_name, "..") == 0)
            continue;
        
        sprintf(fullpath, "%s/%s", dirpath, entry-&gt;d_name);
        
        if (stat(fullpath, &amp;fileStat) == 0) {
            if (S_ISDIR(fileStat.st_mode))
                printf("DIR\t%-10s\t%s\n", "&lt;DIR&gt;", entry-&gt;d_name);
            else if (S_ISREG(fileStat.st_mode))
                printf("FILE\t%-10ld\t%s\n", fileStat.st_size, entry-&gt;d_name);
        }
    }
    
    closedir(dir);
    return 0;
}
</pre>

<h4>How to Run (Ubuntu Terminal):</h4>
<pre>
# Save the code as list_dir_details.c
gcc list_dir_details.c -o list_dir_details
./list_dir_details
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read directory path from the user</li>
    <li>Open the directory for reading</li>
    <li>If directory cannot be opened, display error and exit</li>
    <li>Display header with column names for type, size, and name</li>
    <li>Read each directory entry in a loop</li>
    <li>Skip the dot and dot-dot entries</li>
    <li>Create full path for each entry</li>
    <li>Get file statistics using stat system call</li>
    <li>Check if entry is a directory</li>
    <li>If directory, display type as DIR and size as directory indicator</li>
    <li>Check if entry is a regular file</li>
    <li>If file, display type as FILE and actual file size in bytes</li>
    <li>Display the entry name</li>
    <li>Continue until all entries are processed</li>
    <li>Close the directory</li>
    <li>Exit program</li>
</ol>

<hr>

<h4>Command:</h4>
<pre>
curl -X POST -H "Content-Type: application/json" -d '{"contents":[{"parts":[{"text":"Write a simple code in C for sjf alogorithm in os, also include algorithm(bullet points text simple) and how to run the code. keep things simple and dont include comment lines in between the code"}]}]}' "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=AIzaSyDk2o8-aoxmeK0T7kfyS8yU3j_bIfgNxgk" | grep -o '"text": *"[^"]*"' | sed 's/"text": *"//' | sed 's/"$//' | sed 's/\\n/\n/g'
</pre>

<pre>
curl -X POST -H "Content-Type: application/json" -d '{"contents":[{"parts":[{"text":"Write a simple code in C for sjf alogorithm in os, also include algorithm(bullet points text simple) and how to run the code. keep things simple and dont include comment lines in between the code"}]}]}' "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=AIzaSyDk2o8-aoxmeK0T7kfyS8yU3j_bIfgNxgk" | jq -r '.candidates[0].content.parts[0].text' | less
</pre>

<pre>
AIzaSyDXaoog9Yyjg0QEQuzIURwPQarxk_SKEV4

AIzaSyDHpHEhUDMuCtqs3GwnH4choc5zR_B9Mvg
</pre>

<hr>
    
<p><a href="#top">Back to Top</a></p>

<footer>
    <p>Operating Systems - Programs and Algorithms Reference</p>
    <p>All content in plain HTML for terminal browser compatibility</p>
</footer>

</body>
</html>
